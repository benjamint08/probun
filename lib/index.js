// @bun
async function SendJSON(json,status=200){return new Response(JSON.stringify(json),{headers:{"Content-Type":"application/json"},status})}var Success=function(message,status=200){return SendJSON({message},status)};var Failure=function(message,status=400){return SendJSON({message},status)};var ServerFailure=function(message,status=500){return SendJSON({message},status)};var Redirect=function(destination,status=302){return new Response(null,{status,headers:{Location:destination}})};var Html=function(html,status=200){return new Response(html,{headers:{"Content-Type":"text/html"},status})};async function query(req,query2){const url=new URL(req.url);const params=url.searchParams;const value=params.get(query2);if(!value){return null}else{return value}}async function param(req){const url=new URL(req.url);let splitUrl=req.url.split("/");let id=splitUrl[splitUrl.length-1];if(id===""){id=splitUrl[splitUrl.length-2]}if(!id){return null}else{return id}}var{Glob}=globalThis.Bun;import*as path from"path/posix";import chalk from"chalk";import*as fs from"fs";async function loadFolder(folder){console.log(`${chalk.bold.white(`Loading routes in`)} ${chalk.bold.green(`${folder}`)}...`);const allRoutes=new Glob(`${folder}/*.ts`);for await(let file of allRoutes.scan(".")){file=file.replace(/\\/g,"/");file=file.replace(/routes\//g,"");const splits=file.split("/");const filePath=path.join(process.cwd(),"routes",file);const routeModule=await import(filePath).then((m)=>m.default||m);const getModule=typeof routeModule==="object"?routeModule?.GET:routeModule;const postModule=typeof routeModule==="object"?routeModule?.POST:routeModule;file=file.replace(/.ts/g,"");if(getModule){if(file.includes("[")&&file.includes("]")){const parts=file.split("/");parts[parts.length-1]="params";file=parts.join("/")}get[`${file}`]=getModule}if(postModule){if(file.includes("[")&&file.includes("]")){const parts=file.split("/");parts[parts.length-1]="params";file=parts.join("/")}post[`${file}`]=postModule}}const folders=fs.readdirSync(folder);for(const subfolder of folders){if(subfolder.includes(".")){continue}await loadFolder(path.join(folder,subfolder))}}async function loadRoutes(){const start=Date.now();await loadFolder("routes");console.log(`${chalk.bold.white(`Loaded all routes in`)} ${chalk.bold.green(`${Date.now()-start}ms`)}`)}async function handleRequest(req){const start=Date.now();let customHeaders=new Headers;for(const middleware of premiddlewares){try{await middleware(req,{headers:customHeaders})}catch(error){console.error(`${chalk.bold.red(`Error while processing middleware ${middleware.name}:`)} ${error}`);return ServerFailure("Internal Server Error")}}const userMethod=req.method.toLowerCase();const url=req.url;let isIndex=false;let parsedUrl=new URL(url??"","http://localhost");let reqMessage=`${chalk.bold.white(userMethod.toUpperCase())} ${parsedUrl.pathname}`;if(parsedUrl.pathname==="/favicon.ico"){return new Response("",{status:204})}if(parsedUrl.pathname==="/"){isIndex=true}if(parsedUrl.pathname.endsWith("/")){parsedUrl.pathname=parsedUrl.pathname.substring(0,parsedUrl.pathname.length-1)}let matchingRoute;if(userMethod==="get"){if(isIndex){matchingRoute=get["index"]}else{matchingRoute=get[parsedUrl.pathname.substring(1)];if(!matchingRoute){matchingRoute=get[parsedUrl.pathname.substring(1)+"/index"]}if(!matchingRoute){const parts=parsedUrl.pathname.split("/");parts.pop();let newPath=parts.join("/");newPath=newPath.substring(1);matchingRoute=get[newPath+"/params"]}}}if(userMethod==="post"){if(isIndex){matchingRoute=post["index"]}else{matchingRoute=post[parsedUrl.pathname.substring(1)];if(!matchingRoute){matchingRoute=post[parsedUrl.pathname.substring(1)+"/index"]}if(!matchingRoute){const parts=parsedUrl.pathname.split("/");parts.pop();let newPath=parts.join("/");newPath=newPath.substring(1);matchingRoute=post[newPath+"/params"]}}}if(!matchingRoute){if(log){reqMessage+=` ${chalk.bold.red("404")} ${chalk.bold.gray(`${Date.now()-start}ms`)}`;console.log(reqMessage)}return new Response("Not found.",{status:404})}try{const response=await matchingRoute(req);for(const middleware of postmiddlewares){try{await middleware(req,{headers:customHeaders})}catch(error){console.error(`${chalk.bold.red(`Error while processing middleware ${middleware.name}:`)} ${error}`);return ServerFailure("Internal Server Error")}}const end=Date.now();response.headers.set("x-response-time",`${end-start}ms`);for(const[key,value]of customHeaders){response.headers.set(key,value)}if(log){let color="green";if(response.status>=100&&response.status<200){color="blue"}else if(response.status>=200&&response.status<300){color="green"}else if(response.status>=300&&response.status<400){color="yellow"}else if(response.status>=400&&response.status<500){color="purple"}else if(response.status>=500){color="red"}reqMessage+=` ${chalk.bold[color](response.status)}`;reqMessage+=` ${chalk.bold.gray(`${end-start}ms`)}`;console.log(reqMessage)}return response}catch(error){console.error("Error while processing the requested route: ",error);if(log){reqMessage+=` ${chalk.bold.red("500")} ${chalk.bold.gray(`${Date.now()-start}ms`)}`;console.log(reqMessage)}return ServerFailure("Internal Server Error")}}async function startServer(port=3000,routes="routes",logger=true){await loadRoutes();console.log(`Starting server on port ${port}...`);Bun.serve({port,fetch:handleRequest})}var log=false;var get={};var post={};var premiddlewares=[];var postmiddlewares=[];class ProBun{port;routes;logger;constructor(props){const{port,routes,logger}=props;this.port=port;this.routes=routes;this.logger=logger}start(){log=this.logger;startServer(this.port,this.routes,this.logger)}definePreMiddleware(middleware){premiddlewares.push(middleware);console.log(`Added pre-middleware: ${chalk.bold.green(middleware.name)}`)}definePostMiddleware(middleware){postmiddlewares.push(middleware);console.log(`Added post-middleware: ${chalk.bold.green(middleware.name)}`)}}export{query,param,Success,ServerFailure,SendJSON,Redirect,ProBun,Html,Failure};
