// @bun
var{Glob}=globalThis.Bun;import*as path from"path/posix";import chalk from"chalk";import*as fs from"fs";async function loadFolder(folder){console.log(`${chalk.bold.white(`Loading routes in`)} ${chalk.bold.green(`${folder}`)}...`);const allRoutes=new Glob(`${folder}/*.ts`);for await(let file of allRoutes.scan(".")){file=file.replace(/\\/g,"/");file=file.replace(/routes\//g,"");const splits=file.split("/");const filePath=path.join(process.cwd(),"routes",file);const routeModule=await import(filePath).then((m)=>m.default||m);const getModule=typeof routeModule==="object"?routeModule?.GET:routeModule;const postModule=typeof routeModule==="object"?routeModule?.POST:routeModule;file=file.replace(/.ts/g,"");if(getModule){get[`${file}`]=getModule}if(postModule){post[`${file}`]=postModule}}const folders=fs.readdirSync(folder);for(const subfolder of folders){if(subfolder.includes(".")){continue}await loadFolder(path.join(folder,subfolder))}}async function loadRoutes(){const start=Date.now();await loadFolder("routes");console.log(`${chalk.bold.white(`Loaded all routes in`)} ${chalk.bold.green(`${Date.now()-start}ms`)}`)}async function handleRequest(req){const start=Date.now();const userMethod=req.method.toLowerCase();const url=req.url;let isIndex=false;let parsedUrl=new URL(url??"","http://localhost");let reqMessage=`${chalk.bold.white(userMethod.toUpperCase())} ${parsedUrl.pathname}`;if(parsedUrl.pathname==="/favicon.ico"){return new Response("",{status:204})}if(parsedUrl.pathname==="/"){isIndex=true}let matchingRoute;if(userMethod==="get"){if(isIndex){matchingRoute=get["index"]}else{matchingRoute=get[parsedUrl.pathname.substring(1)];if(!matchingRoute){matchingRoute=get[parsedUrl.pathname.substring(1)+"/index"]}}}if(userMethod==="post"){if(isIndex){matchingRoute=post["index"]}else{matchingRoute=post[parsedUrl.pathname.substring(1)];if(!matchingRoute){matchingRoute=post[parsedUrl.pathname.substring(1)+"/index"]}}}if(!matchingRoute){if(log){reqMessage+=` ${chalk.bold.red("404")} ${chalk.bold.gray(`${Date.now()-start}ms`)}`;console.log(reqMessage)}return new Response("Not found.",{status:404})}try{const response=await matchingRoute(req);const end=Date.now();response.headers.set("x-response-time",`${end-start}ms`);if(log){let color="green";if(response.status>=100&&response.status<200){color="blue"}else if(response.status>=200&&response.status<300){color="green"}else if(response.status>=300&&response.status<400){color="yellow"}else if(response.status>=400&&response.status<500){color="purple"}else if(response.status>=500){color="red"}reqMessage+=` ${chalk.bold[color](response.status)}`;reqMessage+=` ${chalk.bold.gray(`${end-start}ms`)}`;console.log(reqMessage)}return response}catch(error){console.error("Error while processing the requested route: ",error);if(log){reqMessage+=` ${chalk.bold.red("500")} ${chalk.bold.gray(`${Date.now()-start}ms`)}`;console.log(reqMessage)}return new Response("Internal Server Error",{status:500})}}async function startServer(port=3000,routes="routes",logger=true){await loadRoutes();console.log(`Starting server on port ${port}...`);Bun.serve({port,fetch:handleRequest})}var log=false;var get={};var post={};class ProBun{port;routes;logger;constructor(props){const{port,routes,logger}=props;this.port=port;this.routes=routes;this.logger=logger}start(){log=this.logger;startServer(this.port,this.routes,this.logger)}}var probun_default=ProBun;export{probun_default as default};
